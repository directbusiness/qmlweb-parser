{"version":3,"sources":["parser.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"qmlweb.parser.js","sourcesContent":["/* @license\n\n  Copyright (c) 2010 Mihai Bazon <mihai.bazon@gmail.com>\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\n  Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\n  Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n      * Redistributions of source code must retain the above\n        copyright notice, this list of conditions and the following\n        disclaimer.\n\n      * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following\n        disclaimer in the documentation and/or other materials\n        provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  SUCH DAMAGE.\n*/\n\n\n/*\n * QML parser and parsetree'er.\n *\n * Based on Javascript parser written by Mihai Bazon for UglifyJS project.\n * That, again, is a port of Javascript parser by Marijn Haverbeke.\n * Big thanks to both of you (and others involved)!\n * UglifyJS: https://github.com/mishoo/UglifyJS\n * Marijn's parser: http://marijn.haverbeke.nl/parse-js/\n *\n * The primary goal of this file is to offer QML parsing *on top of UglifyJS\n * parser* and to change Javascript parts as little as possible. If you find\n * bugs/improvements to Javascript parsing parts, check if those are fixed to\n * UglifyJS parser first. If not, fix them there. After UglifyJS has been fixed,\n * backport the changes to this file. Less changes to Javascript, more easy it\n * will be to keep up with UglifyJS.\n * Ultimately it would be great to keep the original parser and QML additions in\n * different files but the structure of code does not support that.\n *\n * Exports:\n *\n * - parseQML(src) -- parses QML source and returns it as output tree expected\n *   by the QML engine\n */\n\n// Object cloning for debug prints.\nfunction clone(obj){\n    if(obj == null || typeof(obj) != 'object')\n        return obj;\n\n    var temp = {}; // changed\n\n    for(var key in obj)\n        temp[key] = clone(obj[key]);\n    return temp;\n}\n\n/* -----[ Tokenizer (constants) ]----- */\n\nvar KEYWORDS = array_to_hash([\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"const\",\n        \"continue\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"in\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"switch\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\"\n]);\n\nvar RESERVED_WORDS = array_to_hash([\n        \"abstract\",\n        \"boolean\",\n        \"byte\",\n        \"char\",\n        \"class\",\n        \"debugger\",\n        \"double\",\n        \"enum\",\n        \"export\",\n        \"extends\",\n        \"final\",\n        \"float\",\n        \"goto\",\n        \"implements\",\n        \"import\",\n        \"int\",\n        \"interface\",\n        \"long\",\n        \"native\",\n        \"package\",\n        \"private\",\n        \"protected\",\n        \"public\",\n        \"short\",\n        \"static\",\n        \"super\",\n        \"synchronized\",\n        \"throws\",\n        \"transient\",\n        \"volatile\"\n]);\n\nvar KEYWORDS_BEFORE_EXPRESSION = array_to_hash([\n        \"return\",\n        \"new\",\n        \"delete\",\n        \"throw\",\n        \"else\",\n        \"case\"\n]);\n\nvar KEYWORDS_ATOM = array_to_hash([\n        \"false\",\n        \"null\",\n        \"true\",\n        \"undefined\"\n]);\n\nvar OPERATOR_CHARS = array_to_hash(characters(\"+-*&%=<>!?|~^\"));\n\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n\nvar OPERATORS = array_to_hash([\n        \"in\",\n        \"instanceof\",\n        \"typeof\",\n        \"new\",\n        \"void\",\n        \"delete\",\n        \"++\",\n        \"--\",\n        \"+\",\n        \"-\",\n        \"!\",\n        \"~\",\n        \"&\",\n        \"|\",\n        \"^\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \">>\",\n        \"<<\",\n        \">>>\",\n        \"<\",\n        \">\",\n        \"<=\",\n        \">=\",\n        \"==\",\n        \"===\",\n        \"!=\",\n        \"!==\",\n        \"?\",\n        \"=\",\n        \"+=\",\n        \"-=\",\n        \"/=\",\n        \"*=\",\n        \"%=\",\n        \">>=\",\n        \"<<=\",\n        \">>>=\",\n        \"|=\",\n        \"^=\",\n        \"&=\",\n        \"&&\",\n        \"||\"\n]);\n\nvar WHITESPACE_CHARS = array_to_hash(characters(\" \\n\\r\\t\\u200b\"));\n\nvar PUNC_BEFORE_EXPRESSION = array_to_hash(characters(\"[{}(,.;:\"));\n\nvar PUNC_CHARS = array_to_hash(characters(\"[]{}(),;:\"));\n\nvar REGEXP_MODIFIERS = array_to_hash(characters(\"gmsiy\"));\n\n/* -----[ Tokenizer ]----- */\n\n// regexps adapted from http://xregexp.com/plugins/#unicode\nvar UNICODE = {\n        letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\n        non_spacing_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\n        space_combining_mark: new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),\n        connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")\n};\n\nfunction is_letter(ch) {\n        return UNICODE.letter.test(ch);\n};\n\nfunction is_digit(ch) {\n        ch = ch.charCodeAt(0);\n        return ch >= 48 && ch <= 57; //XXX: find out if \"UnicodeDigit\" means something else than 0..9\n};\n\nfunction is_alphanumeric_char(ch) {\n        return is_digit(ch) || is_letter(ch);\n};\n\nfunction is_unicode_combining_mark(ch) {\n        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\n};\n\nfunction is_unicode_connector_punctuation(ch) {\n        return UNICODE.connector_punctuation.test(ch);\n};\n\nfunction is_identifier_start(ch) {\n        return ch == \"$\" || ch == \"_\" || is_letter(ch);\n};\n\nfunction is_identifier_char(ch) {\n        return is_identifier_start(ch)\n                || is_unicode_combining_mark(ch)\n                || is_digit(ch)\n                || is_unicode_connector_punctuation(ch)\n                || ch == \"\\u200c\" // zero-width non-joiner <ZWNJ>\n                || ch == \"\\u200d\" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\n        ;\n};\n\nfunction parse_js_number(num) {\n        if (RE_HEX_NUMBER.test(num)) {\n                return parseInt(num.substr(2), 16);\n        } else if (RE_OCT_NUMBER.test(num)) {\n                return parseInt(num.substr(1), 8);\n        } else if (RE_DEC_NUMBER.test(num)) {\n                return parseFloat(num);\n        }\n};\n\nfunction QMLParseError(message, line, col, pos, comment) {\n        line = line + 1\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n        this.comment = comment ? comment : \"\";\n        this.message = message + \" (line: \" + line + \", col: \" + col + \", pos: \" + pos + \")\" + \"\\n\" + comment + \"\\n\"\n        this.file = qmlweb_parse.nowParsingFile;\n        try {\n                ({})();\n        } catch(ex) {\n                this.stack = ex.stack;\n        };\n\n};\nQMLParseError.prototype = new Error();\n\nfunction js_error(message, line, col, pos, comment) {\n        throw new QMLParseError(message, line, col, pos, comment);\n};\n\nfunction is_token(token, type, val) {\n        return token.type == type && (val == null || token.value == val);\n};\n\nfunction extractLinesForErrorDiag(text, line)\n{\n  var r = \"\";\n  var lines = text.split(\"\\n\");\n\n  for (var i = line - 3; i <= line + 3; i++)\n  if (i >= 0 && i < lines.length ) {\n      var mark = ( i == line ) ? \">>\" : \"  \";\n      r += mark + (i + 1) + \"  \" + lines[i] + \"\\n\";\n  }\n\n  return r;\n}\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT) {\n\n        var S = {\n                text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\n                pos             : 0,\n                tokpos          : 0,\n                line            : 0,\n                tokline         : 0,\n                col             : 0,\n                tokcol          : 0,\n                newline_before  : false,\n                regex_allowed   : false,\n                comments_before : []\n        };\n\n        function peek() { return S.text.charAt(S.pos); };\n\n        function next(signal_eof) {\n                var ch = S.text.charAt(S.pos++);\n                if (signal_eof && !ch)\n                        throw EX_EOF;\n                if (ch == \"\\n\") {\n                        S.newline_before = true;\n                        ++S.line;\n                        S.col = 0;\n                } else {\n                        ++S.col;\n                }\n                return ch;\n        };\n\n        function eof() {\n                return !S.peek();\n        };\n\n        function find(what, signal_eof) {\n                var pos = S.text.indexOf(what, S.pos);\n                if (signal_eof && pos == -1) throw EX_EOF;\n                return pos;\n        };\n\n        function start_token() {\n                S.tokline = S.line;\n                S.tokcol = S.col;\n                S.tokpos = S.pos;\n        };\n\n        function token(type, value, is_comment) {\n                S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\n                                   (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\n                                   (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\n                var ret = {\n                        type  : type,\n                        value : value,\n                        line  : S.tokline,\n                        col   : S.tokcol,\n                        pos   : S.tokpos,\n                        nlb   : S.newline_before\n                };\n                if (!is_comment) {\n                        ret.comments_before = S.comments_before;\n                        S.comments_before = [];\n                }\n                S.newline_before = false;\n                return ret;\n        };\n\n        function skip_whitespace() {\n                while (HOP(WHITESPACE_CHARS, peek()))\n                        next();\n        };\n\n        function read_while(pred) {\n                var ret = \"\", ch = peek(), i = 0;\n                while (ch && pred(ch, i++)) {\n                        ret += next();\n                        ch = peek();\n                }\n                return ret;\n        };\n\n        function parse_error(err) {\n                js_error(err, S.tokline, S.tokcol, S.tokpos, extractLinesForErrorDiag( S.text, S.tokline ) );\n        };\n\n        function read_num(prefix) {\n                var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n                var num = read_while(function(ch, i){\n                        if (ch == \"x\" || ch == \"X\") {\n                                if (has_x) return false;\n                                return has_x = true;\n                        }\n                        if (!has_x && (ch == \"E\" || ch == \"e\")) {\n                                if (has_e) return false;\n                                return has_e = after_e = true;\n                        }\n                        if (ch == \"-\") {\n                                if (after_e || (i == 0 && !prefix)) return true;\n                                return false;\n                        }\n                        if (ch == \"+\") return after_e;\n                        after_e = false;\n                        if (ch == \".\") {\n                                if (!has_dot && !has_x)\n                                        return has_dot = true;\n                                return false;\n                        }\n                        return is_alphanumeric_char(ch);\n                });\n                if (prefix)\n                        num = prefix + num;\n                var valid = parse_js_number(num);\n                if (!isNaN(valid)) {\n                        return token(\"num\", valid);\n                } else {\n                        parse_error(\"Invalid syntax: \" + num);\n                }\n        };\n\n        function read_escaped_char() {\n                var ch = next(true);\n                switch (ch) {\n                    case \"n\" : return \"\\n\";\n                    case \"r\" : return \"\\r\";\n                    case \"t\" : return \"\\t\";\n                    case \"b\" : return \"\\b\";\n                    case \"v\" : return \"\\v\";\n                    case \"f\" : return \"\\f\";\n                    case \"0\" : return \"\\0\";\n                    case \"x\" : return String.fromCharCode(hex_bytes(2));\n                    case \"u\" : return String.fromCharCode(hex_bytes(4));\n                    case \"\\n\": return \"\";\n                    default  : return ch;\n                }\n        };\n\n        function hex_bytes(n) {\n                var num = 0;\n                for (; n > 0; --n) {\n                        var digit = parseInt(next(true), 16);\n                        if (isNaN(digit))\n                                parse_error(\"Invalid hex-character pattern in string\");\n                        num = (num << 4) | digit;\n                }\n                return num;\n        };\n\n        function read_string() {\n                return with_eof_error(\"Unterminated string constant\", function(){\n                        var quote = next(), ret = \"\";\n                        for (;;) {\n                                var ch = next(true);\n                                if (ch == \"\\\\\") ch = read_escaped_char();\n                                else if (ch == quote) break;\n                                ret += ch;\n                        }\n                        return token(\"string\", ret);\n                });\n        };\n\n        function read_line_comment() {\n                next();\n                var i = find(\"\\n\"), ret;\n                if (i == -1) {\n                        ret = S.text.substr(S.pos);\n                        S.pos = S.text.length;\n                } else {\n                        ret = S.text.substring(S.pos, i);\n                        S.pos = i;\n                }\n                return token(\"comment1\", ret, true);\n        };\n\n        function read_multiline_comment() {\n                next();\n                return with_eof_error(\"Unterminated multiline comment\", function(){\n                        var i = find(\"*/\", true),\n                            text = S.text.substring(S.pos, i),\n                            tok = token(\"comment2\", text, true);\n                        S.pos = i + 2;\n                        S.line += text.split(\"\\n\").length - 1;\n                        S.newline_before = text.indexOf(\"\\n\") >= 0;\n\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/100\n                        if (/^@cc_on/i.test(text)) {\n                                warn(\"WARNING: at line \" + S.line);\n                                warn(\"*** Found \\\"conditional comment\\\": \" + text);\n                                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\n                        }\n\n                        return tok;\n                });\n        };\n\n        function read_name() {\n                var backslash = false, name = \"\", ch;\n                while ((ch = peek()) != null) {\n                        if (!backslash) {\n                                if (ch == \"\\\\\") backslash = true, next();\n                                else if (is_identifier_char(ch)) name += next();\n                                else break;\n                        }\n                        else {\n                                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                                ch = read_escaped_char();\n                                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                                name += ch;\n                                backslash = false;\n                        }\n                }\n                return name;\n        };\n\n        function read_regexp() {\n                return with_eof_error(\"Unterminated regular expression\", function(){\n                        var prev_backslash = false, regexp = \"\", ch, in_class = false;\n                        while ((ch = next(true))) if (prev_backslash) {\n                                regexp += \"\\\\\" + ch;\n                                prev_backslash = false;\n                        } else if (ch == \"[\") {\n                                in_class = true;\n                                regexp += ch;\n                        } else if (ch == \"]\" && in_class) {\n                                in_class = false;\n                                regexp += ch;\n                        } else if (ch == \"/\" && !in_class) {\n                                break;\n                        } else if (ch == \"\\\\\") {\n                                prev_backslash = true;\n                        } else {\n                                regexp += ch;\n                        }\n                        var mods = read_name();\n                        return token(\"regexp\", [ regexp, mods ]);\n                });\n        };\n\n        function read_operator(prefix) {\n                function grow(op) {\n                        if (!peek()) return op;\n                        var bigger = op + peek();\n                        if (HOP(OPERATORS, bigger)) {\n                                next();\n                                return grow(bigger);\n                        } else {\n                                return op;\n                        }\n                };\n                return token(\"operator\", grow(prefix || next()));\n        };\n\n        function handle_slash() {\n                next();\n                var regex_allowed = S.regex_allowed;\n                switch (peek()) {\n                    case \"/\":\n                        S.comments_before.push(read_line_comment());\n                        S.regex_allowed = regex_allowed;\n                        return next_token();\n                    case \"*\":\n                        S.comments_before.push(read_multiline_comment());\n                        S.regex_allowed = regex_allowed;\n                        return next_token();\n                }\n                return S.regex_allowed ? read_regexp() : read_operator(\"/\");\n        };\n\n        function handle_dot() {\n                next();\n                return is_digit(peek())\n                        ? read_num(\".\")\n                        : token(\"punc\", \".\");\n        };\n\n        function read_word() {\n                var word = read_name();\n                return !HOP(KEYWORDS, word)\n                        ? token(\"name\", word)\n                        : HOP(OPERATORS, word)\n                        ? token(\"operator\", word)\n                        : HOP(KEYWORDS_ATOM, word)\n                        ? token(\"atom\", word)\n                        : token(\"keyword\", word);\n        };\n\n        function with_eof_error(eof_error, cont) {\n                try {\n                        return cont();\n                } catch(ex) {\n                        if (ex === EX_EOF) parse_error(eof_error);\n                        else throw ex;\n                }\n        };\n\n        function next_token(force_regexp) {\n                if (force_regexp)\n                        return read_regexp();\n                skip_whitespace();\n                start_token();\n                var ch = peek();\n                if (!ch) return token(\"eof\");\n                if (is_digit(ch)) return read_num();\n                if (ch == '\"' || ch == \"'\") return read_string();\n                if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\n                if (ch == \".\") return handle_dot();\n                if (ch == \"/\") return handle_slash();\n                if (HOP(OPERATOR_CHARS, ch)) return read_operator();\n                if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\n                parse_error(\"Unexpected character '\" + ch + \"'\");\n        };\n\n        next_token.context = function(nc) {\n                if (nc) S = nc;\n                return S;\n        };\n\n        return next_token;\n\n};\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = array_to_hash([\n        \"typeof\",\n        \"void\",\n        \"delete\",\n        \"--\",\n        \"++\",\n        \"!\",\n        \"~\",\n        \"-\",\n        \"+\"\n]);\n\nvar UNARY_POSTFIX = array_to_hash([ \"--\", \"++\" ]);\n\nvar ASSIGNMENT = (function(a, ret, i){\n        while (i < a.length) {\n                ret[a[i]] = a[i].substr(0, a[i].length - 1);\n                i++;\n        }\n        return ret;\n})(\n        [\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\"],\n        { \"=\": true },\n        0\n);\n\nvar PRECEDENCE = (function(a, ret){\n        for (var i = 0, n = 1; i < a.length; ++i, ++n) {\n                var b = a[i];\n                for (var j = 0; j < b.length; ++j) {\n                        ret[b[j]] = n;\n                }\n        }\n        return ret;\n})(\n        [\n                [\"||\"],\n                [\"&&\"],\n                [\"|\"],\n                [\"^\"],\n                [\"&\"],\n                [\"==\", \"===\", \"!=\", \"!==\"],\n                [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n                [\">>\", \"<<\", \">>>\"],\n                [\"+\", \"-\"],\n                [\"*\", \"/\", \"%\"]\n        ],\n        {}\n);\n\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\n\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\n\n/* -----[ Parser ]----- */\n\nfunction NodeWithToken(str, start, end) {\n        this.name = str;\n        this.start = start;\n        this.end = end;\n};\n\nNodeWithToken.prototype.toString = function() { return this.name; };\n\nqmlweb_parse.nowParsingFile = ''; // TODO: make a parameter of qmlweb_parse\nqmlweb_parse.QMLDocument = 1;\nqmlweb_parse.JSResource = 2;\nfunction qmlweb_parse($TEXT, document_type, exigent_mode, embed_tokens) {\n\n        var S = {\n                text        : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\n                input       : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\n                token       : null,\n                prev        : null,\n                peeked      : null,\n                in_function : 0,\n                in_loop     : 0,\n                labels      : []\n        };\n\n        S.token = next();\n\n        function is(type, value) {\n                return is_token(S.token, type, value);\n        };\n\n        function peek() { return S.peeked || (S.peeked = S.input()); };\n\n        function next() {\n                S.prev = S.token;\n                if (S.peeked) {\n                        S.token = S.peeked;\n                        S.peeked = null;\n                } else {\n                        S.token = S.input();\n                }\n                return S.token;\n        };\n\n        function prev() {\n                return S.prev;\n        };\n\n        function croak(msg, line, col, pos) {\n                var ctx = S.input.context();\n                var eLine = (line != null ? line : ctx.tokline);\n                js_error(msg,\n                         eLine,\n                         col != null ? col : ctx.tokcol,\n                         pos != null ? pos : ctx.tokpos,\n                         extractLinesForErrorDiag( S.text, eLine ) );\n        };\n\n        function token_error(token, msg) {\n                croak(msg, token.line, token.col);\n        };\n\n        function unexpected(token) {\n                if (token == null)\n                        token = S.token;\n                token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n        };\n\n        function expect_token(type, val) {\n                if (is(type, val)) {\n                        return next();\n                }\n                token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.val + \", expected \" + type + \" \" + val);\n        };\n\n        function expect(punc) { return expect_token(\"punc\", punc); };\n\n        function can_insert_semicolon() {\n                return !exigent_mode && (\n                        S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\n                );\n        };\n\n        function semicolon() {\n                if (is(\"punc\", \";\")) next();\n                else if (!can_insert_semicolon()) unexpected();\n        };\n\n        function as() {\n                return slice(arguments);\n        };\n\n        function parenthesised() {\n                expect(\"(\");\n                var ex = expression();\n                expect(\")\");\n                return ex;\n        };\n\n        function add_tokens(str, start, end) {\n                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\n        };\n\n        function maybe_embed_tokens(parser) {\n                if (embed_tokens) return function() {\n                        var start = S.token;\n                        var ast = parser.apply(this, arguments);\n                        ast[0] = add_tokens(ast[0], start, prev());\n                        return ast;\n                };\n                else return parser;\n        };\n\n        var statement = maybe_embed_tokens(function() {\n                if (is(\"operator\", \"/\")) {\n                        S.peeked = null;\n                        S.token = S.input(true); // force regexp\n                }\n                switch (S.token.type) {\n                    case \"num\":\n                    case \"string\":\n                    case \"regexp\":\n                    case \"operator\":\n                    case \"atom\":\n                        return simple_statement();\n\n                    case \"name\":\n                        return is_token(peek(), \"punc\", \":\")\n                                ? labeled_statement(prog1(S.token.value, next, next))\n                                : simple_statement();\n\n                    case \"punc\":\n                        switch (S.token.value) {\n                            case \"{\":\n                                return as(\"block\", block_());\n                            case \"[\":\n                            case \"(\":\n                                return simple_statement();\n                            case \";\":\n                                next();\n                                return as(\"block\");\n                            default:\n                                unexpected();\n                        }\n\n                    case \"keyword\":\n                        switch (prog1(S.token.value, next)) {\n                            case \"break\":\n                                return break_cont(\"break\");\n\n                            case \"continue\":\n                                return break_cont(\"continue\");\n\n                            case \"debugger\":\n                                semicolon();\n                                return as(\"debugger\");\n\n                            case \"do\":\n                                return (function(body){\n                                        expect_token(\"keyword\", \"while\");\n                                        return as(\"do\", prog1(parenthesised, semicolon), body);\n                                })(in_loop(statement));\n\n                            case \"for\":\n                                return for_();\n\n                            case \"function\":\n                                return function_(true);\n\n                            case \"if\":\n                                return if_();\n\n                            case \"return\":\n                                if (S.in_function == 0)\n                                        croak(\"'return' outside of function\");\n                                return as(\"return\",\n                                          is(\"punc\", \";\")\n                                          ? (next(), null)\n                                          : can_insert_semicolon()\n                                          ? null\n                                          : prog1(expression, semicolon));\n\n                            case \"switch\":\n                                return as(\"switch\", parenthesised(), switch_block_());\n\n                            case \"throw\":\n                                return as(\"throw\", prog1(expression, semicolon));\n\n                            case \"try\":\n                                return try_();\n\n                            case \"var\":\n                                return prog1(var_, semicolon);\n\n                            case \"const\":\n                                return prog1(const_, semicolon);\n\n                            case \"while\":\n                                return as(\"while\", parenthesised(), in_loop(statement));\n\n                            case \"with\":\n                                return as(\"with\", parenthesised(), statement());\n\n                            default:\n                                unexpected();\n                        }\n                }\n        });\n\n        function labeled_statement(label) {\n                S.labels.push(label);\n                var start = S.token, stat = statement();\n                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\n                        unexpected(start);\n                S.labels.pop();\n                return as(\"label\", label, stat);\n        };\n\n        function simple_statement() {\n                return as(\"stat\", prog1(expression, semicolon));\n        };\n\n        function break_cont(type) {\n                var name = is(\"name\") ? S.token.value : null;\n                if (name != null) {\n                        next();\n                        if (!member(name, S.labels))\n                                croak(\"Label \" + name + \" without matching loop or statement\");\n                }\n                else if (S.in_loop == 0)\n                        croak(type + \" not inside a loop or switch\");\n                semicolon();\n                return as(type, name);\n        };\n\n        function for_() {\n                expect(\"(\");\n                var init = null;\n                if (!is(\"punc\", \";\")) {\n                        init = is(\"keyword\", \"var\")\n                                ? (next(), var_(true))\n                                : expression(true, true);\n                        if (is(\"operator\", \"in\"))\n                                return for_in(init);\n                }\n                return regular_for(init);\n        };\n\n        function regular_for(init) {\n                expect(\";\");\n                var test = is(\"punc\", \";\") ? null : expression();\n                expect(\";\");\n                var step = is(\"punc\", \")\") ? null : expression();\n                expect(\")\");\n                return as(\"for\", init, test, step, in_loop(statement));\n        };\n\n        function for_in(init) {\n                var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\n                next();\n                var obj = expression();\n                expect(\")\");\n                return as(\"for-in\", init, lhs, obj, in_loop(statement));\n        };\n\n        var function_ = maybe_embed_tokens(function(in_statement) {\n                var name = is(\"name\") ? prog1(S.token.value, next) : null;\n                if (in_statement && !name)\n                        unexpected();\n                expect(\"(\");\n                return as(in_statement ? \"defun\" : \"function\",\n                          name,\n                          // arguments\n                          (function(first, a){\n                                  while (!is(\"punc\", \")\")) {\n                                          if (first) first = false; else expect(\",\");\n                                          if (!is(\"name\")) unexpected();\n                                          a.push(S.token.value);\n                                          next();\n                                  }\n                                  next();\n                                  return a;\n                          })(true, []),\n                          // body\n                          (function(){\n                                  ++S.in_function;\n                                  var loop = S.in_loop;\n                                  S.in_loop = 0;\n                                  var a = block_();\n                                  --S.in_function;\n                                  S.in_loop = loop;\n                                  return a;\n                          })());\n        });\n\n        function if_() {\n                var cond = parenthesised(), body = statement(), belse;\n                if (is(\"keyword\", \"else\")) {\n                        next();\n                        belse = statement();\n                }\n                return as(\"if\", cond, body, belse);\n        };\n\n        function block_() {\n                expect(\"{\");\n                var a = [];\n                while (!is(\"punc\", \"}\")) {\n                        if (is(\"eof\")) unexpected();\n                        a.push(statement());\n                }\n                next();\n                return a;\n        };\n\n        var switch_block_ = curry(in_loop, function(){\n                expect(\"{\");\n                var a = [], cur = null;\n                while (!is(\"punc\", \"}\")) {\n                        if (is(\"eof\")) unexpected();\n                        if (is(\"keyword\", \"case\")) {\n                                next();\n                                cur = [];\n                                a.push([ expression(), cur ]);\n                                expect(\":\");\n                        }\n                        else if (is(\"keyword\", \"default\")) {\n                                next();\n                                expect(\":\");\n                                cur = [];\n                                a.push([ null, cur ]);\n                        }\n                        else {\n                                if (!cur) unexpected();\n                                cur.push(statement());\n                        }\n                }\n                next();\n                return a;\n        });\n\n        function try_() {\n                var body = block_(), bcatch, bfinally;\n                if (is(\"keyword\", \"catch\")) {\n                        next();\n                        expect(\"(\");\n                        if (!is(\"name\"))\n                                croak(\"Name expected\");\n                        var name = S.token.value;\n                        next();\n                        expect(\")\");\n                        bcatch = [ name, block_() ];\n                }\n                if (is(\"keyword\", \"finally\")) {\n                        next();\n                        bfinally = block_();\n                }\n                if (!bcatch && !bfinally)\n                        croak(\"Missing catch/finally blocks\");\n                return as(\"try\", body, bcatch, bfinally);\n        };\n\n        function vardefs(no_in) {\n                var a = [];\n                for (;;) {\n                        if (!is(\"name\"))\n                                unexpected();\n                        var name = S.token.value;\n                        next();\n                        if (is(\"operator\", \"=\")) {\n                                next();\n                                a.push([ name, expression(false, no_in) ]);\n                        } else {\n                                a.push([ name ]);\n                        }\n                        if (!is(\"punc\", \",\"))\n                                break;\n                        next();\n                }\n                return a;\n        };\n\n        function var_(no_in) {\n                return as(\"var\", vardefs(no_in));\n        };\n\n        function const_() {\n                return as(\"const\", vardefs());\n        };\n\n        function new_() {\n                var newexp = expr_atom(false), args;\n                if (is(\"punc\", \"(\")) {\n                        next();\n                        args = expr_list(\")\");\n                } else {\n                        args = [];\n                }\n                return subscripts(as(\"new\", newexp, args), true);\n        };\n\n        var expr_atom = maybe_embed_tokens(function(allow_calls) {\n                if (is(\"operator\", \"new\")) {\n                        next();\n                        return new_();\n                }\n                if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\n                        return make_unary(\"unary-prefix\",\n                                          prog1(S.token.value, next),\n                                          expr_atom(allow_calls));\n                }\n                if (is(\"punc\")) {\n                        switch (S.token.value) {\n                            case \"(\":\n                                next();\n                                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\n                            case \"[\":\n                                next();\n                                return subscripts(array_(), allow_calls);\n                            case \"{\":\n                                next();\n                                return subscripts(object_(), allow_calls);\n                        }\n                        unexpected();\n                }\n                if (is(\"keyword\", \"function\")) {\n                        next();\n                        return subscripts(function_(false), allow_calls);\n                }\n                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\n                        var atom = S.token.type == \"regexp\"\n                                ? as(\"regexp\", S.token.value[0], S.token.value[1])\n                                : as(S.token.type, S.token.value);\n                        return subscripts(prog1(atom, next), allow_calls);\n                }\n                unexpected();\n        });\n\n        function expr_list(closing, allow_trailing_comma, allow_empty) {\n                var first = true, a = [];\n                while (!is(\"punc\", closing)) {\n                        if (first) first = false; else expect(\",\");\n                        if (allow_trailing_comma && is(\"punc\", closing)) break;\n                        if (is(\"punc\", \",\") && allow_empty) {\n                                a.push([ \"atom\", \"undefined\" ]);\n                        } else {\n                                a.push(expression(false));\n                        }\n                }\n                next();\n                return a;\n        };\n\n        function array_() {\n                var from = S.token.pos,\n                    stat = expr_list(\"]\", !exigent_mode, true),\n                    to = S.token.pos;\n                return as(\"array\", stat, \"[\" + S.text.substr(from, to - from));\n        };\n\n        function object_() {\n                var first = true, a = [];\n                while (!is(\"punc\", \"}\")) {\n                        if (first) first = false; else expect(\",\");\n                        if (!exigent_mode && is(\"punc\", \"}\"))\n                                // allow trailing comma\n                                break;\n                        var type = S.token.type;\n                        var name = as_property_name();\n                        if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\n                                a.push([ as_name(), function_(false), name ]);\n                        } else {\n                                expect(\":\");\n                                a.push([ name, expression(false) ]);\n                        }\n                }\n                next();\n                return as(\"object\", a);\n        };\n\n        function as_property_name() {\n                switch (S.token.type) {\n                    case \"num\":\n                    case \"string\":\n                        return prog1(S.token.value, next);\n                }\n                return as_name();\n        };\n\n        function as_name() {\n                switch (S.token.type) {\n                    case \"name\":\n                    case \"operator\":\n                    case \"keyword\":\n                    case \"atom\":\n                        return prog1(S.token.value, next);\n                    default:\n                        unexpected();\n                }\n        };\n\n        function subscripts(expr, allow_calls) {\n                if (is(\"punc\", \".\")) {\n                        next();\n                        return subscripts(as(\"dot\", expr, as_name()), allow_calls);\n                }\n                if (is(\"punc\", \"[\")) {\n                        next();\n                        return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\n                }\n                if (allow_calls && is(\"punc\", \"(\")) {\n                        next();\n                        return subscripts(as(\"call\", expr, expr_list(\")\")), true);\n                }\n                if (allow_calls && is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value)) {\n                        return prog1(curry(make_unary, \"unary-postfix\", S.token.value, expr),\n                                     next);\n                }\n                return expr;\n        };\n\n        function make_unary(tag, op, expr) {\n                if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\n                        croak(\"Invalid use of \" + op + \" operator\");\n                return as(tag, op, expr);\n        };\n\n        function expr_op(left, min_prec, no_in) {\n                var op = is(\"operator\") ? S.token.value : null;\n                if (op && op == \"in\" && no_in) op = null;\n                var prec = op != null ? PRECEDENCE[op] : null;\n                if (prec != null && prec > min_prec) {\n                        next();\n                        var right = expr_op(expr_atom(true), prec, no_in);\n                        return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\n                }\n                return left;\n        };\n\n        function expr_ops(no_in) {\n                return expr_op(expr_atom(true), 0, no_in);\n        };\n\n        function maybe_conditional(no_in) {\n                var expr = expr_ops(no_in);\n                if (is(\"operator\", \"?\")) {\n                        next();\n                        var yes = expression(false);\n                        expect(\":\");\n                        return as(\"conditional\", expr, yes, expression(false, no_in));\n                }\n                return expr;\n        };\n\n        function is_assignable(expr) {\n                if (!exigent_mode) return true;\n                switch (expr[0]) {\n                    case \"dot\":\n                    case \"sub\":\n                    case \"new\":\n                    case \"call\":\n                        return true;\n                    case \"name\":\n                        return expr[1] != \"this\";\n                }\n        };\n\n        function maybe_assign(no_in) {\n                var left = maybe_conditional(no_in), val = S.token.value;\n                if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\n                        if (is_assignable(left)) {\n                                next();\n                                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\n                        }\n                        croak(\"Invalid assignment\");\n                }\n                return left;\n        };\n\n        function maybe_qmlelem(no_in) {\n                var expr = maybe_assign(no_in);\n                if (is(\"punc\", \"{\"))\n                    return as(\"qmlelem\", expr[1], undefined, qmlblock());\n                return expr;\n        };\n\n        var expression = maybe_embed_tokens(function(commas, no_in) {\n                if (arguments.length == 0)\n                        commas = true;\n                var expr = maybe_qmlelem(no_in);\n                if (commas && is(\"punc\", \",\")) {\n                        next();\n                        return as(\"seq\", expr, expression(true, no_in));\n                }\n                return expr;\n        });\n\n        function in_loop(cont) {\n                try {\n                        ++S.in_loop;\n                        return cont();\n                } finally {\n                        --S.in_loop;\n                }\n        };\n\n        function qml_is_element(str) {\n            return str[0].toUpperCase() == str[0];\n        }\n\n        function qmlblock() {\n            expect(\"{\");\n            var a = [];\n            while (!is(\"punc\", \"}\")) {\n                if (is(\"eof\")) unexpected();\n                a.push(qmlstatement());\n            }\n            expect(\"}\");\n            return a;\n        }\n\n        function qmlproperty() {\n            switch (S.token.type) {\n                case \"name\":\n                    return as(\"qmlbinding\", statement());\n                case \"num\":\n                case \"string\":\n                    return as(\"qmlvalue\", prog1(S.token.value, next,\n                        semicolon));\n                default:\n                    todo();\n            }\n        }\n\n        function qmlpropdef() {\n            var type = S.token.value;\n            next();\n            var name = S.token.value;\n            next();\n            if (type == \"alias\") {\n                expect(\":\");\n                if (!is(\"name\")) unexpected();\n                var objName = S.token.value;\n                next();\n                if (is(\"punc\", \".\")) {\n                    next();\n                    if (!is(\"name\")) unexpected();\n                    var propName = S.token.value;\n                    next();\n                }\n                return as(\"qmlaliasdef\", name, objName, propName);\n            }\n            if (is(\"punc\", \":\")) {\n                next();\n                S.in_function++;\n                var from = S.token.pos,\n                    stat = statement(),\n                    to = S.token.pos;\n                S.in_function--;\n                return as(\"qmlpropdef\", name, type, stat,\n                        S.text.substr(from, to - from));\n            } else if (is(\"punc\", \";\"))\n                next();\n            return as(\"qmlpropdef\", name, type);\n\n        }\n\n        function qmldefaultprop() {\n            next();\n            expect_token(\"name\", \"property\");\n\n            return as(\"qmldefaultprop\", qmlpropdef());\n        }\n\n        function qmlsignaldef() {\n            var name = S.token.value;\n            next();\n            var args = [];\n            if (is(\"punc\", \"(\")) {\n                next();\n                var first = true;\n                while (!is(\"punc\", \")\")) {\n                        if (first) first = false; else expect(\",\");\n                        if (!is(\"name\")) unexpected();\n                        var type = S.token.value;\n                        next();\n                        if (!is(\"name\")) unexpected();\n                        args.push({type: type, name: S.token.value});\n                        next();\n                }\n                next();\n            }\n            if (is(\"punc\", \";\"))\n                next();\n            return as(\"qmlsignaldef\", name, args);\n\n        }\n\n        function qmlstatement() {\n            if (is(\"keyword\", \"function\")) {\n                var from = S.token.pos;\n                next();\n                var stat = function_(true);\n                var to = S.token.pos;\n                var name = stat[1];\n                return as(\"qmlmethod\", name, stat,\n                    S.text.substr(from, to - from));\n            } else if (is(\"name\", \"signal\")) {\n                next();\n                if (is(\"punc\", \":\")) {\n                    next();\n                    S.in_function++;\n                    var from = S.token.pos,\n                        stat = statement(),\n                        to = S.token.pos;\n                    S.in_function--;\n                    return as(\"qmlprop\", propname, stat,\n                        S.text.substr(from, to - from));\n                } else {\n                    return qmlsignaldef();\n                }\n            } else if (S.token.type == \"name\") {\n                var propname = S.token.value;\n                next();\n                if (propname == \"property\" && (S.token.type == \"name\" || S.token.value == \"var\")) {\n                    return qmlpropdef();\n                } else if (qml_is_element(propname) && !is(\"punc\", \".\")) {\n                    // Element\n                    var onProp;\n                    if (is(\"name\", \"on\")) {\n                        next();\n                        onProp = S.token.value;\n                        next();\n                    }\n                    return as(\"qmlelem\", propname, onProp, qmlblock());\n                } else {\n                    // property statement\n                    if (is(\"punc\", \".\")) {\n                        // anchors, fonts etc, a.b: statement;\n                        // Can also be Component.onCompleted: ...\n                        // Assume only one subproperty\n                        next();\n                        var subname = S.token.value;\n                        next();\n                        expect(\":\");\n                        S.in_function++;\n                        var from = S.token.pos,\n                            stat = statement(),\n                            to = S.token.pos;\n                        S.in_function--;\n                        return as(\"qmlobjdef\", propname, subname, stat,\n                            S.text.substr(from, to - from));\n                    } else if (is(\"punc\", \"{\")) {\n                        return as(\"qmlobj\", propname, qmlblock());\n                    } else {\n                        // Evaluatable item\n                        expect(\":\");\n                        S.in_function++;\n                        var from = S.token.pos,\n                            stat = statement(),\n                            to = S.token.pos;\n                        S.in_function--;\n                        return as(\"qmlprop\", propname, stat,\n                            S.text.substr(from, to - from));\n                    }\n                }\n            } else if (is(\"keyword\", \"default\")) {\n                return qmldefaultprop();\n            } else {\n                todo();\n            }\n        }\n\n        function qmlimport() {\n            // todo\n            next();\n            var moduleName = S.token.value;\n            var isDottedNotation = (S.token.type == \"name\");\n            next();\n            \n            while (is(\"punc\", \".\")) {\n                next();\n                moduleName += \".\" + S.token.value;\n                next();\n            }\n            if (is(\"num\")) {\n                var version = S.token.value\n                next();\n            }\n            var namespace = \"\";\n            if (is(\"name\", \"as\")) {\n                next();\n                namespace = S.token.value;\n                next();\n            }\n            return as(\"qmlimport\", moduleName, version, namespace, isDottedNotation);\n        }\n\n        function qmldocument() {\n            var imports = [];\n            while (is(\"name\", \"import\")) {\n                imports.push(qmlimport());\n            }\n            var root = qmlstatement();\n            if (!is(\"eof\"))\n                unexpected();\n\n            return as(\"toplevel\", imports, root);\n        }\n\n        function jsdocument() {\n            var statements = [];\n            while (!is(\"eof\")) {\n                statements.push(statement());\n            }\n            return as(\"jsresource\", statements);\n        }\n\n        function amIn(s) {\n            console && console.log(s, clone(S), S.token.type, S.token.value);\n        }\n        function todo() {\n            amIn(\"todo parse:\");\n            next();\n        }\n\n        if (document_type === qmlweb_parse.JSResource) {\n            return jsdocument();\n        } else {\n            return qmldocument();\n        }\n\n};\n\n/* -----[ Utilities ]----- */\n\nfunction curry(f) {\n        var args = slice(arguments, 1);\n        return function() { return f.apply(this, args.concat(slice(arguments))); };\n};\n\nfunction prog1(ret) {\n        if (ret instanceof Function)\n                ret = ret();\n        for (var i = 1, n = arguments.length; --n > 0; ++i)\n                arguments[i]();\n        return ret;\n};\n\nfunction array_to_hash(a) {\n        var ret = {};\n        for (var i = 0; i < a.length; ++i)\n                ret[a[i]] = true;\n        return ret;\n};\n\nfunction slice(a, start) {\n        return Array.prototype.slice.call(a, start == null ? 0 : start);\n};\n\nfunction characters(str) {\n        return str.split(\"\");\n};\n\nfunction member(name, array) {\n        for (var i = array.length; --i >= 0;)\n                if (array[i] === name)\n                        return true;\n        return false;\n};\n\nfunction HOP(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\nvar warn = function() {};\n\nexports.qmlweb_parse = qmlweb_parse;\n"],"sourceRoot":"/source/"}